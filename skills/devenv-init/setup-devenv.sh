#!/usr/bin/env bash
# Setup devenv + direnv + jj for a project
# IDEMPOTENT: Safe to run multiple times, will update existing configs
set -euo pipefail

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() { echo -e "${GREEN}[INFO]${NC} $*"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $*"; }
log_error() { echo -e "${RED}[ERROR]${NC} $*"; }
log_section() { echo -e "\n${BLUE}=== $* ===${NC}"; }

# --- JJ REPO CHECK/INIT ---
ensure_jj_repo() {
    if [[ ! -d ".jj" ]]; then
        if [[ -d ".git" ]]; then
            log_info "Git repo found, initializing jj colocated..."
            jj git init --colocate
        else
            log_error "No git or jj repository found"
            log_info "Initialize with: git init && jj git init --colocate"
            exit 1
        fi
    else
        log_info "jj repository found"
    fi
    
    # Check if git-backed (colocated)
    if [[ ! -d ".git" ]]; then
        log_error "jj repo is not git-backed (no .git directory)"
        log_info "Reinitialize with: jj git init --colocate"
        exit 1
    fi
    log_info "jj repo is git-backed (colocated)"
}

# --- GIT REMOTE CHECK ---
check_git_remotes() {
    local remotes
    remotes=$(git remote 2>/dev/null || true)
    if [[ -z "$remotes" ]]; then
        log_warn "No git remotes configured"
        log_warn "Add with: git remote add origin <url>"
    else
        log_info "Git remotes: $(echo "$remotes" | tr '\n' ' ')"
    fi
}

# --- DIRENV SETUP (IDEMPOTENT) ---
setup_direnv() {
    local envrc_content
    local marker="# Auto-generated by devenv-init skill"
    
    envrc_content="$marker"'
# Works with or without devenv installed

if command -v devenv &> /dev/null; then
    eval "$(devenv print-dev-env 2>/dev/null || echo "")"
    if [[ -z "${DEVENV_ROOT:-}" ]]; then
        echo "devenv print-dev-env failed, using basic direnv"
        use_nix 2>/dev/null || true
    fi
else
    if has nix; then
        use_nix 2>/dev/null || true
    fi
fi

PATH_add bin 2>/dev/null || true
'
    
    if [[ -f ".envrc" ]]; then
        if grep -q "$marker" .envrc 2>/dev/null; then
            log_info ".envrc already managed by devenv-init, updating..."
        else
            log_warn ".envrc exists but not managed by devenv-init, backing up..."
            cp .envrc ".envrc.bak.$(date +%s)"
        fi
    fi
    
    echo "$envrc_content" > .envrc
    log_info "Created/updated .envrc"
    
    if command -v direnv &> /dev/null; then
        direnv allow . 2>/dev/null || log_warn "direnv allow failed"
        log_info "direnv allowed"
    else
        log_warn "direnv not installed"
    fi
}

# --- DETECT LANGUAGE ---
detect_language() {
    if [[ -f "Cargo.toml" ]]; then echo "rust"
    elif [[ -f "pyproject.toml" ]] || [[ -f "setup.py" ]]; then echo "python"
    elif [[ -f "package.json" ]]; then echo "node"
    elif [[ -f "go.mod" ]]; then echo "go"
    else echo "unknown"
    fi
}

# --- ANALYZE REPO FOR TOOLS/SCRIPTS/TASKS ---
analyze_repo() {
    log_section "Analyzing repository"
    
    local packages=()
    local scripts=()
    local tasks=()
    local processes=()
    local hooks=()
    local lang
    lang=$(detect_language)
    
    log_info "Primary language: $lang"
    
    # Common tools detection
    [[ -f "Makefile" ]] && packages+=("gnumake") && log_info "Found: Makefile"
    [[ -f "justfile" ]] && packages+=("just") && log_info "Found: justfile"
    [[ -f ".pre-commit-config.yaml" ]] && log_info "Found: pre-commit config"
    
    # Rust-specific
    if [[ "$lang" == "rust" ]]; then
        packages+=("cargo-watch" "cargo-nextest")
        
        # Check for common patterns in Cargo.toml
        if grep -q "cargo-deb" Cargo.toml 2>/dev/null; then
            packages+=("cargo-deb")
            log_info "Found: cargo-deb dependency"
        fi
        
        # Use ::: as delimiter (unlikely to appear in commands)
        scripts+=('check:::cargo fmt --all --check && cargo clippy --all-targets && cargo test')
        scripts+=('dev:::cargo watch -x check -x test')
        tasks+=('build:::cargo build --release')
        tasks+=('test:::cargo test')
        hooks+=("rustfmt" "clippy")
        
        # Look for binary targets (processes)
        if grep -q '\[\[bin\]\]' Cargo.toml 2>/dev/null || grep -q 'name.*=.*"' Cargo.toml 2>/dev/null; then
            local bin_name
            bin_name=$(grep -m1 'name.*=' Cargo.toml | sed 's/.*=.*"\([^"]*\)".*/\1/' || echo "app")
            log_info "Found binary: $bin_name"
        fi
    fi
    
    # Python-specific
    if [[ "$lang" == "python" ]]; then
        packages+=("ruff" "uv")
        
        if [[ -f "pyproject.toml" ]]; then
            if grep -q "pytest" pyproject.toml 2>/dev/null; then
                scripts+=('test:::pytest')
                tasks+=('test:::pytest')
                log_info "Found: pytest"
            fi
            if grep -q "ruff" pyproject.toml 2>/dev/null; then
                scripts+=('lint:::ruff check .')
                scripts+=('format:::ruff format .')
                hooks+=("ruff")
                log_info "Found: ruff config"
            fi
        fi
        
        if [[ -f "requirements.txt" ]]; then
            scripts+=('install:::pip install -r requirements.txt')
        fi
    fi
    
    # Node-specific
    if [[ "$lang" == "node" ]]; then
        # Detect package manager
        if [[ -f "pnpm-lock.yaml" ]]; then
            packages+=("pnpm")
            scripts+=('install:::pnpm install')
            log_info "Found: pnpm"
        elif [[ -f "yarn.lock" ]]; then
            packages+=("yarn")
            scripts+=('install:::yarn install')
            log_info "Found: yarn"
        else
            scripts+=('install:::npm install')
        fi
        
        # Parse package.json scripts
        if [[ -f "package.json" ]]; then
            if grep -q '"test"' package.json 2>/dev/null; then
                tasks+=('test:::npm test')
            fi
            if grep -q '"build"' package.json 2>/dev/null; then
                tasks+=('build:::npm run build')
            fi
            if grep -q '"dev"' package.json 2>/dev/null; then
                processes+=('dev:::npm run dev')
            fi
            if grep -q '"lint"' package.json 2>/dev/null; then
                scripts+=('lint:::npm run lint')
            fi
        fi
        
        # TypeScript
        if [[ -f "tsconfig.json" ]]; then
            log_info "Found: TypeScript"
        fi
        
        # Frameworks
        [[ -f "next.config.js" ]] || [[ -f "next.config.mjs" ]] && log_info "Found: Next.js"
        [[ -d "prisma" ]] && log_info "Found: Prisma"
    fi
    
    # Go-specific
    if [[ "$lang" == "go" ]]; then
        packages+=("golangci-lint")
        scripts+=('test:::go test ./...')
        scripts+=('lint:::golangci-lint run')
        tasks+=('build:::go build ./...')
        tasks+=('test:::go test ./...')
        hooks+=("gofmt")
    fi
    
    # Output analysis as JSON-ish for the next step
    echo
    log_info "Recommended devenv.nix configuration:"
    echo
    echo "  packages: ${packages[*]:-none}"
    echo "  scripts: ${#scripts[@]} detected"
    echo "  tasks: ${#tasks[@]} detected"
    echo "  processes: ${#processes[@]} detected"
    echo "  pre-commit hooks: ${hooks[*]:-none}"
    
    # Store in temp file for generate step
    {
        echo "LANG=$lang"
        echo "PACKAGES=(${packages[*]:-})"
        printf 'SCRIPTS=(%s)\n' "$(printf '"%s" ' "${scripts[@]:-}")"
        printf 'TASKS=(%s)\n' "$(printf '"%s" ' "${tasks[@]:-}")"
        printf 'PROCESSES=(%s)\n' "$(printf '"%s" ' "${processes[@]:-}")"
        echo "HOOKS=(${hooks[*]:-})"
    } > /tmp/devenv-analysis.sh
}

# --- GENERATE DEVENV.NIX ---
generate_devenv_nix() {
    local force="${1:-false}"
    local marker="# Generated by devenv-init skill"
    
    # Check if already exists and managed
    if [[ -f "devenv.nix" ]]; then
        if grep -q "$marker" devenv.nix 2>/dev/null; then
            if [[ "$force" != "true" ]]; then
                log_info "devenv.nix already managed by devenv-init"
                log_info "Run with --force to regenerate"
                return 0
            fi
            log_info "Regenerating devenv.nix..."
        else
            log_warn "devenv.nix exists but not managed by devenv-init"
            log_warn "Backing up to devenv.nix.bak"
            cp devenv.nix "devenv.nix.bak.$(date +%s)"
        fi
    fi
    
    # Source analysis
    source /tmp/devenv-analysis.sh 2>/dev/null || {
        log_warn "No analysis found, running analyze first..."
        analyze_repo
        source /tmp/devenv-analysis.sh
    }
    
    # Build the nix file
    cat > devenv.nix << NIXEOF
$marker
# Re-run: bash .claude/skills/devenv-init/setup-devenv.sh --force
{ pkgs, lib, config, inputs, ... }:

{
  packages = [
    pkgs.git
    pkgs.jujutsu
NIXEOF

    # Add detected packages
    for pkg in "${PACKAGES[@]:-}"; do
        [[ -n "$pkg" ]] && echo "    pkgs.$pkg" >> devenv.nix
    done
    
    cat >> devenv.nix << 'NIXEOF'
  ];

NIXEOF

    # Language config
    case "$LANG" in
        rust)
            cat >> devenv.nix << 'NIXEOF'
  languages.rust = {
    enable = true;
    channel = "stable";
  };

NIXEOF
            ;;
        python)
            cat >> devenv.nix << 'NIXEOF'
  languages.python = {
    enable = true;
    version = "3.12";
    venv.enable = true;
  };

NIXEOF
            ;;
        node)
            cat >> devenv.nix << 'NIXEOF'
  languages.javascript = {
    enable = true;
    npm.enable = true;
  };

NIXEOF
            ;;
        go)
            cat >> devenv.nix << 'NIXEOF'
  languages.go.enable = true;

NIXEOF
            ;;
    esac

    # Scripts
    echo "  scripts = {" >> devenv.nix
    for script in "${SCRIPTS[@]:-}"; do
        if [[ -n "$script" ]]; then
            local name="${script%%:::*}"
            local cmd="${script#*:::}"
            echo "    $name.exec = \"$cmd\";" >> devenv.nix
        fi
    done
    echo "  };" >> devenv.nix
    echo >> devenv.nix

    # Tasks
    echo "  tasks = {" >> devenv.nix
    for task in "${TASKS[@]:-}"; do
        if [[ -n "$task" ]]; then
            local name="${task%%:::*}"
            local cmd="${task#*:::}"
            echo "    \"devenv:$name\".exec = \"$cmd\";" >> devenv.nix
        fi
    done
    echo "  };" >> devenv.nix
    echo >> devenv.nix

    # Processes
    echo "  processes = {" >> devenv.nix
    for proc in "${PROCESSES[@]:-}"; do
        if [[ -n "$proc" ]]; then
            local name="${proc%%:::*}"
            local cmd="${proc#*:::}"
            echo "    $name.exec = \"$cmd\";" >> devenv.nix
        fi
    done
    echo "  };" >> devenv.nix
    echo >> devenv.nix

    # Pre-commit hooks
    echo "  pre-commit.hooks = {" >> devenv.nix
    for hook in "${HOOKS[@]:-}"; do
        [[ -n "$hook" ]] && echo "    $hook.enable = true;" >> devenv.nix
    done
    echo "  };" >> devenv.nix
    echo >> devenv.nix

    # Close
    cat >> devenv.nix << 'NIXEOF'
  enterTest = ''
    echo "Running devenv tests..."
  '';
}
NIXEOF

    log_info "Generated devenv.nix"
}

# --- DEVENV.YAML (IDEMPOTENT) ---
ensure_devenv_yaml() {
    local marker="# Generated by devenv-init skill"
    
    if [[ -f "devenv.yaml" ]]; then
        if grep -q "$marker" devenv.yaml 2>/dev/null; then
            log_info "devenv.yaml already managed"
            return 0
        else
            log_info "devenv.yaml exists, leaving unchanged"
            return 0
        fi
    fi
    
    cat > devenv.yaml << EOF
$marker
inputs:
  nixpkgs:
    url: github:cachix/devenv-nixpkgs/rolling
EOF
    
    log_info "Created devenv.yaml"
}

# --- MAIN ---
main() {
    local force=false
    local analyze_only=false
    
    # Parse args
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force|-f) force=true; shift ;;
            --analyze|-a) analyze_only=true; shift ;;
            --help|-h)
                echo "Usage: $0 [OPTIONS]"
                echo "Options:"
                echo "  --force, -f    Regenerate devenv.nix even if managed"
                echo "  --analyze, -a  Only analyze repo, don't generate files"
                echo "  --help, -h     Show this help"
                exit 0
                ;;
            *) shift ;;
        esac
    done
    
    log_section "Checking prerequisites"
    ensure_jj_repo
    check_git_remotes
    
    # Always analyze
    analyze_repo
    
    if [[ "$analyze_only" == "true" ]]; then
        log_info "Analysis complete (--analyze mode)"
        exit 0
    fi
    
    log_section "Setting up devenv"
    setup_direnv
    ensure_devenv_yaml
    generate_devenv_nix "$force"
    
    log_section "Setup complete"
    echo
    echo "Files created/updated:"
    echo "  - .envrc (direnv)"
    echo "  - devenv.yaml (inputs)"
    echo "  - devenv.nix (configuration)"
    echo
    echo "Next steps:"
    echo "  1. Review devenv.nix and customize as needed"
    echo "  2. Run 'devenv shell' or 'cd .' to activate"
    echo "  3. Re-run with --force to regenerate after changes"
}

main "$@"
